//
//  MainScreenInteractor.swift
//  concreto-filmes
//
//  Created by Leonel Menezes on 23/10/18.
//  Copyright (c) 2018 Leonel Menezes. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol MainScreenBusinessLogic {
    func fetchPopularMovies(shouldResetMovies: Bool)
    func filterMoviesLocally(text: String)
    func fetchQueriedMovies(text: String, shouldResetMovies: Bool)
    func initialFetch()
}

protocol MainScreenDataStore {
    var movies: [Movie] { get set }
    var filteredMovies: [Movie] { get set }
    var currentPageForAPIPopular: Int { get set }
    var currentPageForAPIFiltering: Int { get set }
}

class MainScreenInteractor: MainScreenBusinessLogic, MainScreenDataStore {
    var presenter: MainScreenPresentationLogic?
    var worker = MainScreenWorker()
    var movies: [Movie] = []
    var filteredMovies: [Movie] = []
    var currentPageForAPIPopular = 1
    var currentPageForAPIFiltering = 1

    func fetchPopularMovies(shouldResetMovies: Bool) {
        if shouldResetMovies {self.currentPageForAPIPopular = 1}
        worker.fetchPopularMovies(request: MainScreen.FetchPopularMovies.Request(index: currentPageForAPIPopular), completion: { (movies, error) in

            self.presentMoviesOrError(movies: movies, persistentMovieList: &self.movies, error: error, shouldResetMovies: shouldResetMovies, pageReference: &self.currentPageForAPIPopular)
        })
    }

    func fetchQueriedMovies(text: String, shouldResetMovies: Bool) {
        if shouldResetMovies {self.currentPageForAPIFiltering = 1}
        worker.fetchMoviesByQuery(request: MainScreen.FetchQueryMovies.Request(index: self.currentPageForAPIFiltering, text: text)) { (movies, error) in

            self.presentMoviesOrError(movies: movies, persistentMovieList: &self.filteredMovies, error: error, shouldResetMovies: shouldResetMovies, pageReference: &self.currentPageForAPIFiltering)
        }
    }

    func initialFetch() {
        worker.fetchAllMovieGenres { (result) in
            switch result {
            case .success:
                self.fetchPopularMovies(shouldResetMovies: true)
            case .failure(let error):
                self.presenter?.present(error: error)
            }
        }
    }

    func presentMoviesOrError(movies: [Movie]?, persistentMovieList: inout [Movie], error: String?, shouldResetMovies: Bool, pageReference: inout Int) {
        if error != nil {
            self.presenter?.present(error: error)
        }
        if let movies = movies {
            if shouldResetMovies {
                persistentMovieList = movies
            } else {
                persistentMovieList.append(contentsOf: movies)
            }
            pageReference += 1
            self.presenter?.present(movies: persistentMovieList)
        }
    }

    func filterMoviesLocally(text: String) {
        if text == "" {
            self.presenter?.present(movies: self.movies)
            return
        }
        let filteredMovies = movies.filter({ (movie) -> Bool in
            return movie.title.lowercased().contains(text.lowercased())
        })
        self.presenter?.present(movies: filteredMovies)
    }
}
