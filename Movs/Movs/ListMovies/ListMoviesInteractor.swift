//
//  ListMoviesInteractor.swift
//  Movs
//
//  Created by Lucas Ferraço on 15/09/18.
//  Copyright (c) 2018 Lucas Ferraço. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ListMoviesBusinessLogic {
	func getMovies()
	func getImage(forMovieId movieId: Int, _ completion: @escaping (UIImage) -> Void)
	func setSelectedMovie(with id: Int)
	func favoriteMovie(with id: Int)
	func checkForNewFavorite()
}

protocol ListMoviesDataStore {
	var selectedMovie: Movie! { get set }
	var isFavorite: Bool! { get set }
}

class ListMoviesInteractor: ListMoviesBusinessLogic, ListMoviesDataStore {
	var presenter: ListMoviesPresentationLogic?
	var worker = ListMoviesWorker()
	var selectedMovie: Movie!
	var isFavorite: Bool!
	
	// MARK: Auxiliary variables
	
	var movies: [Movie] = []
	var favoriteMovies: [Movie] = []
	
	// MARK: Get Movies
	
	func getMovies() {
		if let storedMovies = worker.fetchFavorites(ofType: Movie.self) {
			favoriteMovies = storedMovies
		}
		
		worker.downloadPopularMovies({ (success, returnedMovies: [Movie]?, error)  in
			if let returnedMovies = returnedMovies {
				self.movies = returnedMovies
			}
			let moviesInfo: [ListMovies.MovieInfo]? = returnedMovies?.map(self.getResponseMovieInfo)
			
			let response = ListMovies.GetMovies.Response(isSuccess: success, error: error, movies: moviesInfo)
			self.presenter?.presentMovies(with: response)
		})
	}
	
	//MARK: Get Movie Image
	
	func getImage(forMovieId movieId: Int, _ completion: @escaping (UIImage) -> Void) {
		guard let movie = self.movies.first(where: { (movie) -> Bool in
			return movie.id == movieId
		}) else { return }
		
		if let storedImageData = movie.posterImageData, let image = self.presenter?.mountMovieImage(from: storedImageData) {
			completion(image)
		} else {
			worker.getImageForMovie(withId: movieId) { (result) in
				if let data = result.imageData, let image = self.presenter?.mountMovieImage(from: data) {
					movie.posterImageData = data
					completion(image)
				}
			}
		}
	}
	
	//MARK: Set selected Movie
	
	func setSelectedMovie(with id: Int) {
		guard let selectedMovie = movies.first(where: { (movie) -> Bool in
			return movie.id == id
		}) else { return }
		
		self.selectedMovie = selectedMovie
		self.isFavorite = favoriteMovies.contains(selectedMovie)
	}
	
	//MARK: Favorite Movie
	
	func favoriteMovie(with id: Int) {
		guard let selectedMovie = movies.first(where: { (movie) -> Bool in
			return movie.id == id
		}) else { return }
		
		if let i = favoriteMovies.index(of: selectedMovie) {
			favoriteMovies.remove(at: i)
			_ = worker.removeFromFavorites(selectedMovie)
		} else {
			favoriteMovies.append(selectedMovie)
			_ = worker.saveToFavorites(selectedMovie)
		}
	}
	
	//MARK: Check for Favorite Movie
	
	/// Checks if the favorite state of the movie presented by SeeMovieDetails changed
	func checkForNewFavorite() {
		guard selectedMovie != nil, isFavorite != favoriteMovies.contains(selectedMovie) else { return }
		
		if isFavorite != favoriteMovies.contains(selectedMovie) {
			if let i = favoriteMovies.index(of: selectedMovie) {
				favoriteMovies.remove(at: i)
			} else {
				favoriteMovies.append(selectedMovie)
			}
		}
		
		let moviesInfo: [ListMovies.MovieInfo]? = movies.map(self.getResponseMovieInfo)
		
		let response = ListMovies.GetMovies.Response(isSuccess: true, error: nil, movies: moviesInfo)
		self.presenter?.presentMovies(with: response)
	}
	
	// MARK: Auxiliary methods
	
	private func getResponseMovieInfo(from movie: Movie) -> ListMovies.MovieInfo {		
		let isFav = favoriteMovies.contains(movie)
		
		return ListMovies.MovieInfo(id: movie.id, title: movie.title, genres: movie.genres, releaseDate: movie.releaseDate, isFavorite: isFav)
	}
}
